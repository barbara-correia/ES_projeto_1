author: @JoanaRitaCruz

Pattern 1:

Code Snippet: 
    (...)
private State myState;
    (...)
public void setGraphics(Graphics2D g) {
        this.myGraphics = g;
        this.myState = null;
    }
    (...)
public Object getState() {
        if (this.myState == null) {
            this.myState = new State(this.myGraphics.getFontRenderContext(), this.myGraphics.getFont());
        }

        return this.myState;
    }

Location on the code base: code/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/render/TextLengthCalculatorImpl.java 

Pattern identification:
- Singleton – A classe estática State não pode ser instanciada sem uma instância da classe TextLengthCalculatorImpl,nesta outer classe é possível observar 
que pode haver uma única instância de State(myState)e que no método getState() só criamos novas instâncias de State se myState == null, 
se já existir uma instancia então retornamos o myState que é único.

#########################################################################################################
Pattern 2:


Code Snippet: 

public class Canvas{
  private ArrayList<Rectangle> myRectangles = new ArrayList<Rectangle>();

  private ArrayList<Line> myLines = new ArrayList<Line>();

  private ArrayList<Text> myTexts = new ArrayList<Text>();

  private Map<Object, Shape> myModelObject2primitive = new WeakHashMap<Object, Shape>();

       (...)
    public static class Shape {
       (...)
       public Color getBackgroundColor() {
      		return myBackgroundColor;
    	}

    	public void setBackgroundColor(Color myBackgroundColor) {
      		this.myBackgroundColor = myBackgroundColor;
    	}
       (...)
    public static class Polygon extends Shape
       (...)
    public static class Rectangle extends Polygon {
       (...)
       public Paint getBackgroundPaint() {
      		return myPaint;
    	}

    	public void setBackgroundPaint(Paint paint) {
      		myPaint = paint;
    	}
	
       (...)
    public static class Rhombus extends Polygon
       (...)
    public static class Arrow extends Shape
       (...)
    public static class Line extends Shape 
       (...)
    (De volta a classe Canvas)
    public Rhombus createRhombus(int leftx, int topy, int diagWidth, int diagHeight) {
    Rhombus rhombus = new Rhombus(leftx, topy, diagWidth, diagHeight);
    myRhombusIndex.put(rhombus, rhombus.getLeftX(), rhombus.getBottomY(), rhombus.getWidth(), rhombus.getHeight());
    return rhombus;
  }

  public Rectangle createRectangle(int leftx, int topy, int width, int height) {
    Rectangle result = createDetachedRectangle(leftx, topy, width, height);
    myRectangles.add(result);
    return result;
  }

  public Rectangle createDetachedRectangle(int leftx, int topy, int width, int height) {
    if (width < 0) {
      width = -width;
      leftx = leftx - width;
    }
    return new Rectangle(leftx + myDeltaX, topy + myDeltaY, width, height);
  }

  public Line createLine(int startx, int starty, int finishx, int finishy) {
    Line result = new Line(startx + myDeltaX, starty + myDeltaY, finishx + myDeltaX, finishy + myDeltaY);
    myLines.add(result);
    return result;
  }
      (...)
       
Location on the code base:
ES_projeto_1/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/canvas/Canvas.java


Pattern identification: 
Factory Method- A classe Canvas juntamente com a classe Shape(com inicio na linha 63) aninhada nesta, 
segue com as suas subclasses um Factory Method Pattern. 
Shape define uma shape geral e depois outras classes que a estendem(direta ou indiretamente) 
como Rectangle e Line (entre outras) que representam uma forma (shape) específica com alguns campos comuns 
e outros específicos de um retângulo e uma linha, respetivamente. A classe Canvas tem os métodos
que criam os vários tipos de shapes de que a mesma necessita.

#########################################################################################################
Pattern 3:

Code Snippet: 

public interface SceneBuilder {
  /**
   * Resets this builder and sets scene height, which is a height of a user-visible viewport 
   * of a chart
   * 
   * @param sceneHeight
   */
  void reset(int sceneHeight);
  
  /**
   * Builds a scene 
   */
  void build();
  
  /**
   * @return canvas instance
   */
  Canvas getCanvas();
}
       (...)
public abstract class AbstractSceneBuilder implements SceneBuilder
       (...)
public class DayGridSceneBuilder extends AbstractSceneBuilder
       (...)
public class BottomUnitSceneBuilder extends AbstractSceneBuilder
       (...)
(Entre outras classes)

Location on the code base: 
ES_projeto_1/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/scene/
ES_projeto_1/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/scene/SceneBuilder.java
ES_projeto_1/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/scene/AbstractSceneBuilder.java
ES_projeto_1/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/scene/DayGridSceneBuilder.java
ES_projeto_1/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/scene/BottomUnitSceneBuilder.java

Pattern identification:
- Templade Method – A interface SceneBuilder juntamente com a classe abstrata que a implementa, AbstractSceneBuilder,
funcionam como a “receita” a seguir para construir uma cena, ou seja, são um template para que classes como DayGridSceneBuilder e BottomUnitSceneBuilder
possam adaptar esta construção e algoritmo para construir um género específico de cena, no caso uma DayGrindScene e uma BottomUnitScene. 
Note-se que ainda existem mais classes na pasta "scene" que estendem AbstractSceneBuilder para criar outras variações de cenas através deste template.
                        
