author: @JoanaRitaCruz

Code Smell 1:

Code Snippet:

  public class Canvas {
  private ArrayList<Rectangle> myRectangles = new ArrayList<Rectangle>();

  private ArrayList<Line> myLines = new ArrayList<Line>();

  private ArrayList<Text> myTexts = new ArrayList<Text>();

  private Map<Object, Shape> myModelObject2primitive = new WeakHashMap<Object, Shape>();

  private List<Canvas> myLayers = new ArrayList<Canvas>();

  private int myDeltaX;

  private int myDeltaY;

  private List<TextGroup> myTextGroups = new ArrayList<TextGroup>();

  private final DummySpatialIndex<Text> myTextIndex = new DummySpatialIndex<Text>();

  private final DummySpatialIndex<Rhombus> myRhombusIndex = new DummySpatialIndex<>();

  /** Horizontal alignments for texts */
  public enum HAlignment {
    CENTER, LEFT, RIGHT
  };

  /** Vertical alignments for texts */
  public enum VAlignment {
    CENTER, TOP, BOTTOM
  };

  public static class Shape {
    private Color myBackgroundColor;

    private Color myForegroundColor;

    private String myStyleName;

           (...)
  }

  public static class Polygon extends Shape {
    private final int myLeftX;
    private final int myRightX;
    private final int myTopY;
    private final int myBottomY;

    private final int[] myPointsX;
    private final int[] myPointsY;

    private Polygon(int... points) {
      myPointsX = new int[points.length / 2];
      myPointsY = new int[points.length / 2];

      int leftX = Integer.MAX_VALUE;
      int topY = Integer.MAX_VALUE;
      int rightX = Integer.MIN_VALUE;
      int bottomY = Integer.MIN_VALUE;
      for (int i = 0; i < points.length / 2; i++) {
        leftX = Math.min(leftX, points[i * 2]);
        rightX = Math.max(rightX, points[i * 2]);
        topY = Math.min(topY, points[i * 2 + 1]);
        bottomY = Math.max(bottomY, points[i * 2 + 1]);

        myPointsX[i] = points[i * 2];
        myPointsY[i] = points[i * 2 + 1];
      }
      myLeftX = leftX;
      myRightX = rightX;
      myTopY = topY;
      myBottomY = bottomY;
    }

          (...)

  public static class Rectangle extends Polygon {
    public Paint myPaint;

    private Rectangle(int leftx, int topy, int width, int height) {
      super(leftx, topy, leftx + width, topy + height);
    }

    public Paint getBackgroundPaint() {
      return myPaint;
    }

    public void setBackgroundPaint(Paint paint) {
      myPaint = paint;
    }
  }

  public static class Rhombus extends Polygon {
    private Rhombus(int leftx, int topy, int diagWidth, int diagHeight) {
      super(
          leftx, topy + diagHeight / 2,
          leftx + diagWidth / 2, topy,
          leftx + diagWidth, topy + diagHeight / 2,
          leftx + diagWidth / 2, topy + diagHeight
      );
    }
  }

  public static class Arrow extends Shape {
    public static Arrow NONE = new Arrow(0, 0);
    public static Arrow FINISH = new Arrow(7, 3);
    private final int myLength;
    private final int myWidth;

         (...)

  public static class Line extends Shape {
    private final int myStartX;

    private final int myStartY;

    private final int myFinishX;

    private final int myFinishY;

    private Arrow myArrow = Arrow.NONE;

        (...)

  public static class Label 
        (...)

  public static class Text extends Shape {
        (...)

  public static class TextGroup {
        (...)

Location on the code base: 
code/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/canvas/Canvas.java

Code Smell identification: 
  Large Class- A classe Canvas tem várias classes aninhadas tornando esta classe muito extensa (703 linhas). 
  Apesar de as subclasses terem a sua função nas operações da classe de topo este aninhamento, devido principalmente à dimensão que a classe adquire, 
  torna o código confuso e difícil de ler e temos vários objetos diferentes a serem representados e especificados nesta classe tornando-a muito complexa.


Refactoring proposal: 
  Separar as classes aninhadas nas suas próprias classes e ficheiros e seguir uma hierarquia das classes relacionadas, por exemplo, Line é uma subclasse de Shape.


################################################################################################

Code Smell 2:

Code Snippet:

public class ShapeConstants {
    public static final ShapePaint TRANSPARENT = new ShapePaint(4, 4, new int[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0});
    public static final ShapePaint DEFAULT = new ShapePaint(4, 4, new int[]{1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1});
    public static final ShapePaint CROSS = new ShapePaint(4, 4, new int[]{0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0});
    public static final ShapePaint VERT = new ShapePaint(4, 4, new int[]{1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0});
    public static final ShapePaint HORZ = new ShapePaint(4, 4, new int[]{0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1});
    public static final ShapePaint GRID = new ShapePaint(4, 4, new int[]{1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1});
    public static final ShapePaint ROUND = new ShapePaint(4, 4, new int[]{0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0});
    public static final ShapePaint NW_TRIANGLE = new ShapePaint(4, 4, new int[]{1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0});
    public static final ShapePaint NE_TRIANGLE = new ShapePaint(4, 4, new int[]{0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0});
    public static final ShapePaint SW_TRIANGLE = new ShapePaint(4, 4, new int[]{0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0});
    public static final ShapePaint SE_TRIANGLE = new ShapePaint(4, 4, new int[]{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1});
    public static final ShapePaint DIAMOND = new ShapePaint(4, 4, new int[]{0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0});
    public static final ShapePaint DOTS = new ShapePaint(4, 4, new int[]{1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0});
    public static final ShapePaint DOT = new ShapePaint(4, 4, new int[]{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0});
    public static final ShapePaint SLASH = new ShapePaint(4, 4, new int[]{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1});
    public static final ShapePaint BACKSLASH = new ShapePaint(4, 4, new int[]{0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0});
    public static final ShapePaint THICK_VERT = new ShapePaint(4, 4, new int[]{0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0});
    public static final ShapePaint THICK_HORZ = new ShapePaint(4, 4, new int[]{0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0});
    public static final ShapePaint THICK_GRID = new ShapePaint(4, 4, new int[]{0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0});
    public static final ShapePaint THICK_SLASH = new ShapePaint(4, 4, new int[]{1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1});
    public static final ShapePaint THICK_BACKSLASH = new ShapePaint(4, 4, new int[]{0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1});
    public static ShapePaint[] PATTERN_LIST;

    public ShapeConstants() {
    }

    static {
        PATTERN_LIST = new ShapePaint[]{TRANSPARENT, DEFAULT, CROSS, VERT, HORZ, GRID, ROUND, NW_TRIANGLE, NE_TRIANGLE, SW_TRIANGLE, SE_TRIANGLE, DIAMOND, DOTS, DOT, SLASH, BACKSLASH, THICK_VERT, THICK_HORZ, THICK_GRID, THICK_SLASH, THICK_BACKSLASH};
    }
}

Location on the code base: code/ biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/canvas/render/ShapeConstants.java

Code Smell identification: 
  Classe de constantes em vez de enumerado - Esta classe define uma espécie de lista de constantes em vez de usar, por exemplo, um enumerado, é uma classe que, 
  para além das constantes em si tem um array (PATTERN_LIST) destas constantes que e difícil de navegar, pois para obter uma constante em particular teríamos de saber 
  o seu index no array.

Refactoring proposal:
	Transformar esta classe num enumerado ou definir as constantes nas classes que as utilizam.


################################################################################################

Code Smell 3:

Code Snippet:
  (...)

  public void drawDependencies(Collection<Connector> connectors) {
        if (this.myChartApi.getBarHeight() != this.myBarHeight) {
            this.myFinishArrow = new Canvas.Arrow((int)(0.7F * (float)this.myChartApi.getBarHeight()), (int)(0.3F * (float)this.myChartApi.getBarHeight()));
            this.myBarHeight = this.myChartApi.getBarHeight();
        }

        Canvas primitiveContainer = this.myOutputCanvas;
        Iterator var3 = connectors.iterator();

        while(var3.hasNext()) {
            Connector connector = (Connector)var3.next();
            Connector.Vector dependantVector = connector.getEnd();
            Connector.Vector dependeeVector = connector.getStart();
            String lineStyle = connector.getStyleName();
            Point first;
            Point third;
            if (dependeeVector.getHProjection().reaches(dependantVector.getHProjection().getPoint())) {
                first = new Point(dependeeVector.getPoint().x, dependeeVector.getPoint().y);
                int xEntry = dependantVector.getPoint().x;
                int yEntry = dependantVector.getPoint().y;
                third = new Point(xEntry, dependeeVector.getPoint().y);
                Point third = new Point(xEntry, yEntry);
                primitiveContainer.createLine(first.x, first.y, third.x, third.y).setStyle(lineStyle);
                Canvas.Line secondLine = primitiveContainer.createLine(third.x, third.y, third.x, third.y);
                secondLine.setStyle(lineStyle);
                secondLine.setArrow(this.myFinishArrow);
            } else {
                Point second;
                if (dependantVector.getHProjection().reaches(dependeeVector.getHProjection().getPoint(3))) {
                    first = dependeeVector.getPoint(3);
                    second = new Point(first.x, dependantVector.getPoint().y);
                    primitiveContainer.createLine(dependeeVector.getPoint().x, dependeeVector.getPoint().y, first.x, first.y).setStyle(lineStyle);
                    primitiveContainer.createLine(first.x, first.y, second.x, second.y).setStyle(lineStyle);
                    Canvas.Line line = primitiveContainer.createLine(second.x, second.y, dependantVector.getPoint().x, dependantVector.getPoint().y);
                    line.setStyle(lineStyle);
                    line.setArrow(this.myFinishArrow);
                } else {
                    first = dependeeVector.getPoint(10);
                    second = dependantVector.getPoint(10);
                    Point second = new Point(first.x, (first.y + second.y) / 2);
                    third = new Point(second.x, (first.y + second.y) / 2);
                    primitiveContainer.createLine(dependeeVector.getPoint().x, dependeeVector.getPoint().y, first.x, first.y).setStyle(lineStyle);
                    primitiveContainer.createLine(first.x, first.y, second.x, second.y).setStyle(lineStyle);
                    primitiveContainer.createLine(second.x, second.y, third.x, third.y).setStyle(lineStyle);
                    primitiveContainer.createLine(third.x, third.y, second.x, second.y).setStyle(lineStyle);
                    Canvas.Line lastLine = primitiveContainer.createLine(second.x, second.y, dependantVector.getPoint().x, dependantVector.getPoint().y);
                    lastLine.setStyle(lineStyle);
                    lastLine.setArrow(this.myFinishArrow);
                }
            }
        }

    }

  (...)

Location on the code base: 
Code/biz.ganttproject.core/src/main/java/biz/ganttproject/core/chart/scene/gantt/DependencySceneBuilder.java

Code Smell identification: 
  Large method- O método drawDependencies() tal como outros nesta classe é bastante extenso( 52 linhas) tornando-o difícil de compreender 
  e dificultando também a identificação de possíveis problemas.

Refactoring proposal: 
  Criar alguns métodos auxiliares para usar no corpo deste método de modo a fatorizá-lo em tarefas mais pequenas.

