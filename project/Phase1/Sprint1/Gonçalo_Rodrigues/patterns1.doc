Pattern 1:

Code Snippet: 
    (...)
    public class DefaultDateOption extends GPAbstractOption<Date> implements DateOption
    (...)
    public class DefaultDoubleOption extends GPAbstractOption<Double> implements DoubleOption
    (...)
    public class DefaultEnumerationOption<T> extends GPAbstractOption<String> implements EnumerationOption
    (...)
    public class DefaultFileOption extends DefaultStringOption implements FileOption
    (...)
    public class DefaultFontOption extends GPAbstractOption<FontSpec> implements FontOption
    (...)
    public class DefaultIntegerOption extends GPAbstractOption<Integer> implements IntegerOption
    (...)
    public class DefaultMoneyOption extends GPAbstractOption<BigDecimal> implements MoneyOption
    (...)
    public class DefaultStringOption extends GPAbstractOption<String> implements StringOption
    (...)
    (Entre outras classes)


Location on the code base: code/biz.ganttproject.core/src/main/java/biz/ganttproject/core/option


Pattern identification:
- Template Method: A class "GPAbstractOption" é extendida por grande parte da das classes da pasta "Option". A class GPAbstractOption
implementa alguns métodos iguais para todas as suas subclasses mas estas implementam outros métodos que tem implementações diferentes, que
variam de classe para classe de acordo com o objetivo e as necessidades do cliente. Assim reusa-se código (está na superclasse em vez de 
estar em todas as subclasses, repetido) e torna o código mais flexível e versátil no caso de ser preciso fazer algum ajuste ou mudança.

#########################################################################################################
Pattern 2:


Code Snippet: 
    (on TaskManagerImpt.java)

        private final TaskImpl myRoot;

        (...)

        private TaskImpl createRootTask() {
            Calendar c = CalendarFactory.newCalendar();
            Date today = c.getTime();
            TaskImpl root = new GanttTask(null, CalendarFactory.createGanttCalendar(today), 1, this, -1, "");
            root.setStart(CalendarFactory.createGanttCalendar(today));
            root.setDuration(createLength(getConfig().getTimeUnitStack().getDefaultTimeUnit(), 1));
            root.setExpand(true);
            root.setName("root");
            return root;
        }

        (...)

        public Date getProjectStart() {
            if (myTaskMap.isEmpty()) {
            return myRoot.getStart().getTime();
            }
            Result result = getAlgorithmCollection().getProjectBoundsAlgorithm().getBounds(tasksToActivities(myTaskMap.getTasks()));
            return result.lowerBound;
        }
    (on PertChart.java)
    
        (...)

        TaskManager myTaskManager;

        (...)

        public Date getStartDate() {
            return myTaskManager.getProjectStart();
        }


        (...)

    (on GanttTask.java)

        (...)

        public class GanttTask extends TaskImpl implements Serializable {

            public GanttTask(String name, GanttCalendar start, long length, TaskManagerImpl taskManager, int taskID, @NotNull String taskUid) {
                super(taskManager, taskID, taskUid);
                setName(name);
                setStart(start);
                setDuration(taskManager.createLength(length));
                enableEvents(true);
            }
        }

        (...)



Location on the code base:

code\ganttproject\src\main\java\net\sourceforge\ganttproject\task\TaskManagerImpl.java
code\org.ganttproject.chart.pert\src\main\java\org\ganttproject\chart\pert\PertChart.java
code\ganttproject\src\main\java\net\sourceforge\ganttproject\GanttTask.java


Pattern identification: 
Command - A classe "TaskManagerImpl.java" funciona como classe de comandos entre muitas outras classes, entre elas a classe "PertChart.java" e 
a classe "GanttTask.java" e estas duas classes, embora nunca tenham acesso à outra, conseguem comunicar entre si através da 
classe "TaskManagerImpl.java".

PS: Embora tenha sido atribuido o pattern Command, este exemplo também se puderá enquadrar no pattern Facade onde as classes q usam a classe
"TaskManagerImpl.java" não tem acesso direto às classes comandadas por ela.

Pattern 1:

Code Snippet: 

    (on UIFacade.java)
        public interface UIFacade {
            (... +/- 120 linhas de codigo ...)
        }

    (on UIFacadeImpl.java)

    class UIFacadeImpl extends ProgressProvider implements UIFacade {
        private final JFrame myMainFrame;
        private final ScrollingManager myScrollingManager;
        private final ZoomManager myZoomManager;
        private final GanttStatusBar myStatusBar;
        private final UIFacade myFallbackDelegate;
        private final TaskSelectionManager myTaskSelectionManager;
        private final List<GPOptionGroup> myOptionGroups = Lists.newArrayList();
        private final GPOptionGroup myOptions;
        private final LafOption myLafOption;
        private final GPOptionGroup myLogoOptions;
        private final DefaultFileOption myLogoOption;
        private final NotificationManagerImpl myNotificationManager;
        private final TaskView myTaskView = new TaskView();
        private final DialogBuilder myDialogBuilder;
        private final Map<String, Font> myOriginalFonts = Maps.newHashMap();
        private final List<Runnable> myOnUpdateComponentTreeUiCallbacks = Lists.newArrayList();
        private float myLastScale = 0;

Location on the code base: 
code\ganttproject\src\main\java\net\sourceforge\ganttproject\gui\UIFacade.java
code\ganttproject\src\main\java\net\sourceforge\ganttproject\UIFacadeImpl.java

Pattern identification:
- Facade Method: A interface "UIFacade" implementa bastantes métodos que tem como objetivo alterar o estado de outras classes,
que juntas formam o subsistema da da classe que a interface "UIFacade" implementa, a classe "UIFacadeImpl.java". Podemos 
admitir que a maior parte das variáveis da classe "UIFacadeImpl.java" (acima, na secção 'Code Spinnet') são instancias 
das suas subclasses. 


                        